name: CI/CD Pipeline

# This workflow auto-formats code, then runs linting, testing, and building
# All in one sequential pipeline to ensure CI always runs on formatted code
# Runs only on pull requests to avoid duplicate runs

on:
  pull_request:
    branches:
      - main

jobs:
  # Job 1: Auto-format code and commit if needed
  format:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Allow pushing formatting changes
    
    outputs:
      formatted_sha: ${{ steps.get-sha.outputs.sha }}
    
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref_name }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-3.13-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --no-interaction --with dev

      - name: Run autopep8 (whitespace cleanup)
        run: |
          poetry run autopep8 --in-place --recursive --select=W src/ tests/
          echo "‚úÖ autopep8 whitespace cleanup complete"

      - name: Run Black formatter
        run: |
          poetry run black src/ tests/
          echo "‚úÖ Black formatting complete"

      - name: Run isort
        run: |
          poetry run isort src/ tests/
          echo "‚úÖ Import sorting complete"

      - name: Check for formatting changes
        id: verify-changed-files
        run: |
          if [[ -z $(git status --porcelain) ]]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No formatting changes needed"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "üìù Formatting changes detected:"
            git status --short
          fi

      - name: Commit formatting changes
        if: steps.verify-changed-files.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "style: auto-format code with autopep8, Black and isort"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current SHA for next jobs
        id: get-sha
        run: |
          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "üìç Current SHA: $(git rev-parse HEAD)"

  # Job 2: Lint (runs on formatted code)
  lint:
    needs: format
    runs-on: ubuntu-latest
    
    steps:
      - name: Check out formatted code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.format.outputs.formatted_sha }}

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-3.13-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --no-interaction --with dev

      - name: Run Black check
        run: poetry run black --check src/ tests/

      - name: Run isort check
        run: poetry run isort --check-only src/ tests/

      - name: Run flake8 linting
        run: poetry run flake8 src/ tests/

      - name: Run mypy type checking
        run: poetry run mypy src/ --ignore-missing-imports

  # Job 3: Test (runs after lint passes)
  test:
    needs: [format, lint]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write  # Allow posting comments
    
    strategy:
      matrix:
        python-version: ['3.13']
    
    steps:
      - name: Check out formatted code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.format.outputs.formatted_sha }}

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --no-interaction --with dev

      - name: Install GDAL system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gdal-bin libgdal-dev

      - name: Run tests with coverage
        id: pytest
        continue-on-error: true
        run: |
          poetry run pytest tests/ -v --cov=src/agri_toolkit --cov-report=xml --cov-report=term

      - name: Upload coverage to Codecov
        if: steps.pytest.outcome == 'success'
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

      - name: Generate test data visualization map
        id: generate-map
        continue-on-error: true
        run: |
          # Find the test GeoJSON file
          GEOJSON_FILE=$(find data/raw/field_boundaries -name "*.geojson" -type f | head -n 1)
          
          if [ -z "$GEOJSON_FILE" ]; then
            echo "status=no_data" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  No test data found"
            exit 0
          fi
          
          echo "Found test data: $GEOJSON_FILE"
          
          # Generate map
          mkdir -p test_artifacts
          python scripts/generate_test_map.py "$GEOJSON_FILE" test_artifacts/test_data_map.html
          
          if [ -f test_artifacts/test_data_map.html ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "map_path=test_artifacts/test_data_map.html" >> $GITHUB_OUTPUT
            echo "‚úÖ Map generated successfully"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Map generation failed"
          fi

      - name: Upload test data map as artifact
        if: steps.generate-map.outputs.status == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: test-data-map-py${{ matrix.python-version }}
          path: test_artifacts/test_data_map.html
          retention-days: 7

      - name: Create or update PR comment with map
        uses: actions/github-script@v7
        env:
          PYTHON_VERSION: ${{ matrix.python-version }}
          MAP_STATUS: ${{ steps.generate-map.outputs.status }}
          TEST_STATUS: ${{ steps.pytest.outcome }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const pythonVersion = process.env.PYTHON_VERSION;
            const mapStatus = process.env.MAP_STATUS;
            const testStatus = process.env.TEST_STATUS;
            
            // Comment marker for identifying our comment
            const commentMarker = `<!-- test-data-preview-py${pythonVersion} -->`;
            
            let commentBody;
            
            if (testStatus !== 'success') {
              // Tests failed
              commentBody = `${commentMarker}
            ## ‚ùå Test Data Preview (Python ${pythonVersion})
            
            **Tests Failed** - Unable to generate test data visualization.
            
            Please check the test logs for details.
            
            ---
            *Last updated: ${new Date().toISOString()}*
            `;
            } else if (mapStatus === 'no_data') {
              // No test data found
              commentBody = `${commentMarker}
            ## ‚ö†Ô∏è Test Data Preview (Python ${pythonVersion})
            
            **No Test Data Found** - Tests passed but no field boundary data was generated.
            
            This may be expected if tests don't download actual data.
            
            ---
            *Last updated: ${new Date().toISOString()}*
            `;
            } else if (mapStatus === 'success') {
              // Map generated successfully
              const runId = context.runId;
              const mapUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
              
              commentBody = `${commentMarker}
            ## ‚úÖ Test Data Preview (Python ${pythonVersion})
            
            **Tests Passed** - Field boundary data downloaded and visualized successfully!
            
            ### üó∫Ô∏è Interactive Map
            
            üì¶ **Download the interactive map:**
            1. Go to the [workflow run artifacts](${mapUrl})
            2. Download **test-data-map-py${pythonVersion}.zip**
            3. Extract and open **test_data_map.html** in your browser
            
            ### üåæ Features
            
            - **Base Maps**: Choose from OpenStreetMap, Satellite, Terrain, or Topo
            - **Field Selection**: Dropdown to zoom to specific fields
            - **Field Details**: Click any field to see metadata (ID, state, county, crop, acreage)
            - **Self-Contained**: No server required, works offline
            
            ### üìä Test Summary
            
            - **Python Version**: ${pythonVersion}
            - **Test Status**: ‚úÖ All tests passed
            - **Data Source**: USDA Crop Sequence Boundaries (Source Cooperative)
            - **Map Generated**: Yes
            
            ---
            *Last updated: ${new Date().toISOString()}*
            *This comment auto-updates on each CI/CD run*
            `;
            } else {
              // Map generation failed
              commentBody = `${commentMarker}
            ## ‚ö†Ô∏è Test Data Preview (Python ${pythonVersion})
            
            **Map Generation Failed** - Tests passed but map generation encountered an error.
            
            Check the workflow logs for details.
            
            ---
            *Last updated: ${new Date().toISOString()}*
            `;
            }
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes(commentMarker)
            );
            
            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
              console.log('Updated existing comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
              console.log('Created new comment');
            }

      - name: Fail if tests failed
        if: steps.pytest.outcome != 'success'
        run: exit 1

  # Job 4: Build (runs after lint and test pass)
  build:
    needs: [format, lint, test]
    runs-on: ubuntu-latest
    
    steps:
      - name: Check out formatted code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.format.outputs.formatted_sha }}

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Install dependencies
        run: poetry install --no-interaction

      - name: Build package
        run: poetry build

      - name: Check if PR and has artifact label
        id: check-upload
        run: |
          LABELS=$(gh pr view ${{ github.event.pull_request.number }} --json labels --jq '.labels[].name')
          if echo "$LABELS" | grep -q "generate-build-artifact"; then
            echo "should_upload=true" >> $GITHUB_OUTPUT
          else
            echo "should_upload=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload build artifacts
        if: steps.check-upload.outputs.should_upload == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: dist-packages
          path: dist/
          retention-days: 7

      - name: Build summary
        run: |
          echo "‚úÖ Build completed successfully"
          if [ "${{ steps.check-upload.outputs.should_upload }}" == "true" ]; then
            echo "üì¶ Artifacts uploaded (generate-build-artifact label present)"
          else
            echo "‚ÑπÔ∏è  Artifacts not stored (add 'generate-build-artifact' label to store)"
          fi
