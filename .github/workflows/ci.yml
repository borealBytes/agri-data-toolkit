name: CI/CD Pipeline

# This workflow auto-formats code, then runs linting, testing, and building
# All in one sequential pipeline to ensure CI always runs on formatted code
# Runs on push to any branch (not on PRs to avoid duplicate runs)

on:
  push:
    branches:
      - '**'  # Run on all branches on every push

jobs:
  # Job 1: Auto-format code and commit if needed
  format:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Allow pushing formatting changes
    
    outputs:
      formatted_sha: ${{ steps.get-sha.outputs.sha }}
    
    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref_name }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-3.13-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --no-interaction --with dev

      - name: Run autopep8 (whitespace cleanup)
        run: |
          poetry run autopep8 --in-place --recursive --select=W src/ tests/
          echo "‚úÖ autopep8 whitespace cleanup complete"

      - name: Run Black formatter
        run: |
          poetry run black src/ tests/
          echo "‚úÖ Black formatting complete"

      - name: Run isort
        run: |
          poetry run isort src/ tests/
          echo "‚úÖ Import sorting complete"

      - name: Check for formatting changes
        id: verify-changed-files
        run: |
          if [[ -z $(git status --porcelain) ]]; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No formatting changes needed"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "üìù Formatting changes detected:"
            git status --short
          fi

      - name: Commit formatting changes
        if: steps.verify-changed-files.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "style: auto-format code with autopep8, Black and isort"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current SHA for next jobs
        id: get-sha
        run: |
          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "üìç Current SHA: $(git rev-parse HEAD)"

  # Job 2: Lint (runs on formatted code)
  lint:
    needs: format
    runs-on: ubuntu-latest
    
    steps:
      - name: Check out formatted code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.format.outputs.formatted_sha }}

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-3.13-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --no-interaction --with dev

      - name: Run Black check
        run: poetry run black --check src/ tests/

      - name: Run isort check
        run: poetry run isort --check-only src/ tests/

      - name: Run flake8 linting
        run: poetry run flake8 src/ tests/

      - name: Run mypy type checking
        run: poetry run mypy src/ --ignore-missing-imports

  # Job 3: Test (runs after lint passes)
  test:
    needs: [format, lint]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write  # Allow posting comments on issues/PRs
    
    strategy:
      matrix:
        python-version: ['3.13']
    
    steps:
      - name: Check out formatted code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.format.outputs.formatted_sha }}

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --no-interaction --with dev

      - name: Install GDAL system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gdal-bin libgdal-dev

      - name: Run tests with coverage
        id: pytest
        continue-on-error: true
        run: |
          poetry run pytest tests/ -v --cov=src/agri_toolkit --cov-report=xml --cov-report=term

      - name: Upload coverage to Codecov
        if: steps.pytest.outcome == 'success'
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

      - name: Generate test data visualization map
        id: generate-map
        continue-on-error: true
        run: |
          # Find the test GeoJSON file
          GEOJSON_FILE=$(find data/raw/field_boundaries -name "*.geojson" -type f | head -n 1)
          
          if [ -z "$GEOJSON_FILE" ]; then
            echo "status=no_data" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  No test data found"
            exit 0
          fi
          
          echo "Found test data: $GEOJSON_FILE"
          
          # Generate map
          mkdir -p test_artifacts
          python scripts/generate_test_map.py "$GEOJSON_FILE" test_artifacts/test_data_map.html
          
          if [ -f test_artifacts/test_data_map.html ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "map_path=test_artifacts/test_data_map.html" >> $GITHUB_OUTPUT
            echo "‚úÖ Map generated successfully"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Map generation failed"
          fi

      - name: Upload test data map as artifact
        if: steps.generate-map.outputs.status == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: test-data-map-py${{ matrix.python-version }}
          path: test_artifacts/test_data_map.html
          retention-days: 7

      - name: Fail if tests failed
        if: steps.pytest.outcome != 'success'
        run: exit 1

  # Job 4: Build (runs after lint and test pass)
  build:
    needs: [format, lint, test]
    runs-on: ubuntu-latest
    
    steps:
      - name: Check out formatted code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.format.outputs.formatted_sha }}

      - name: Set up Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Install dependencies
        run: poetry install --no-interaction

      - name: Build package
        run: poetry build

      - name: Build summary
        run: |
          echo "‚úÖ Build completed successfully"
          echo "üì¶ Package built: $(ls dist/)"
